package repository

import (
	"documentation/entity"
	"fmt"

	"gorm.io/gorm"
)

type FeatureRepository interface {
	SaveFeature(feature entity.Feature) (entity.Feature, error)
	UpdateFeature(feature entity.Feature) (entity.Feature, error)
	FindByIDFeature(ID int) (entity.Feature, error)
	FindAllFeature() ([]entity.Feature, error)
	DeleteByIDFeature(ID int) (entity.Feature, error)
	FindAll(search string, page int, size int) ([]entity.Feature, error)
	TotalFetchData(search string, page int, size int) (int, error)
}

type featureRepository struct {
	db *gorm.DB
}

func NewFeatureRepository(db *gorm.DB) *featureRepository {
	return &featureRepository{db}
}

func (r *featureRepository) SaveFeature(feature entity.Feature) (entity.Feature, error) {
	err := r.db.Create(&feature).Error
	if err != nil {
		return feature, err
	}
	return feature, nil

}
func (r *featureRepository) FindByIDFeature(ID int) (entity.Feature, error) {
	var feature entity.Feature
	err := r.db.Where("id = ? ", ID).Find(&feature).Error
	if err != nil {
		return feature, err
	}
	return feature, nil

}
func (r *featureRepository) UpdateFeature(feature entity.Feature) (entity.Feature, error) {
	err := r.db.Save(&feature).Error
	if err != nil {
		return feature, err
	}
	return feature, nil

}
func (r *featureRepository) FindAllFeature() ([]entity.Feature, error) {
	var features []entity.Feature
	err := r.db.Find(&features).Error
	if err != nil {
		return features, err
	}
	return features, nil

}
func (r *featureRepository) DeleteByIDFeature(ID int) (entity.Feature, error) {
	var feature entity.Feature
	err := r.db.Where("id = ? ", ID).Delete(&feature).Error
	if err != nil {
		return feature, err
	}
	return feature, nil

}

func (r *featureRepository) FindAll(search string, page int, size int) ([]entity.Feature, error) {
	var feature []entity.Feature
	searchQuery := search
	sql := "SELECT * FROM features WHERE 1=1 "
	if searchQuery != "" {
		sql = fmt.Sprintf("%s AND (feature_name LIKE '%%%s%%') ", sql, searchQuery)
	}
	start := (page * size)
	limit := 0
	if start < 0 {
		limit = 0
	} else {
		limit = start
	}
	length := size

	sql = fmt.Sprintf("%s ORDER BY id DESC LIMIT %d OFFSET %d", sql, length, limit)

	err := r.db.Raw(sql).Scan(&feature).Error
	if err != nil {
		return feature, err
	}
	return feature, nil

}

func (r *featureRepository) TotalFetchData(search string, page int, size int) (int, error) {
	var features []entity.Feature
	searchQuery := search
	sql := "SELECT * FROM features WHERE 1=1 "
	// SELECT * FROM users where 1=1 and (nama_lengkap LIKE '%joko%' OR user_name like '%joko%')
	if searchQuery != "" {
		sql = fmt.Sprintf("%s AND (feature_name LIKE '%%%s%%') ", sql, searchQuery)
	}

	err := r.db.Raw(sql).Scan(&features).Error
	if err != nil {
		return len(features), err
	}
	return len(features), nil
}

//Generated by Micagen at 25 Mei 2022
